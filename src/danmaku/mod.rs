mod baha;
mod bilibili;
mod bilivideo;
mod douyu;
mod fudujikiller;
mod huya;
mod mkv_header;
mod twitch;
mod youtube;

use crate::config::Site;
use crate::dmlive::DMLContext;
use anyhow::Result;
use chrono::{Duration, NaiveTime};
use log::info;
use std::cell::Cell;
use std::cell::RefCell;
use std::collections::BTreeMap;
use std::ops::{BitXor, Not};
use std::rc::Rc;
use tokio::io::AsyncWriteExt;
use tokio::sync::Notify;

const ASS_HEADER_TEXT: &'static str = r#"[Script Info]
; Script generated by dmlive 
; https://github.com/THMonster/Revda
Title: Danmaku file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Sans,40,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,0,7,0,0,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"#;
// const EMOJI_RE: &'static str = r#"[\x{1F300}-\x{1F5FF}|\x{1F1E6}-\x{1F1FF}|\x{2700}-\x{27BF}|\x{1F900}-\x{1F9FF}|\x{1F600}-\x{1F64F}|\x{1F680}-\x{1F6FF}|\x{2600}-\x{26FF}]"#;

#[derive(Clone, Debug)]
struct DanmakuChannel {
    length: usize,
    begin_pts: u64,
}

#[derive(Clone, Debug)]
pub struct DMLDanmaku {
    time: i64,
    text: String,
    nick: String,
    color: String,
    position: u8,
}

pub struct Danmaku {
    ctx: Rc<DMLContext>,
    show_nick: Cell<bool>,
    font_size: Cell<usize>,
    channel_num: Cell<usize>,
    ratio_scale: Cell<f64>,
    read_order: Cell<usize>,
    dchannels: RefCell<Vec<DanmakuChannel>>,
    fk: fudujikiller::FudujiKiller,
    pub ready_notify: (Notify, Cell<bool>),
}

impl Danmaku {
    pub fn new(ctx: Rc<DMLContext>) -> Self {
        let font_size = (40.0 * ctx.cm.font_scale.get()) as usize;
        let ch = vec![
            DanmakuChannel {
                length: 0,
                begin_pts: 0
            };
            30
        ];
        Self {
            ctx,
            show_nick: Cell::new(false),
            font_size: Cell::new(font_size),
            channel_num: Cell::new((540.0 / font_size as f64).ceil() as usize),
            ratio_scale: Cell::new(1.0),
            read_order: Cell::new(0),
            fk: fudujikiller::FudujiKiller::new(),
            dchannels: RefCell::new(ch),
            ready_notify: (Notify::new(), Cell::new(false)),
        }
    }

    pub fn reset(&self) {
        for it in self.dchannels.borrow_mut().iter_mut() {
            it.length = 0;
            it.begin_pts = 0;
        }
        self.read_order.set(0)
    }

    pub async fn set_speed(&self, speed: u64) {
        if (1000..30000).contains(&speed) {
            self.ctx.cm.danmaku_speed.set(speed);
            let _ = self.ctx.cm.write_config().await;
        }
    }

    pub async fn set_font_size(&self, font_scale: f64) {
        if font_scale > 0.0 {
            self.font_size.set((40.0 * font_scale) as usize);
            self.channel_num.set((540.0 / self.font_size.get() as f64).ceil() as usize);
            self.ctx.cm.font_scale.set(font_scale);
            let _ = self.ctx.cm.write_config().await;
        }
    }

    pub async fn set_font_alpha(&self, font_alpha: f64) {
        if (0.0..=1.0).contains(&font_alpha) {
            self.ctx.cm.font_alpha.set(font_alpha);
            let _ = self.ctx.cm.write_config().await;
        }
    }

    pub fn set_ratio_scale(&self, ratio_scale: f64) {
        self.ratio_scale.set(ratio_scale);
    }

    pub async fn toggle_show_nick(&self) {
        self.show_nick.set(self.show_nick.get().bitxor(true));
    }

    fn get_avail_danmaku_channel(&self, c_pts: u64, len: usize) -> Option<usize> {
        let s = (1920.0 + len as f64) / self.ctx.cm.danmaku_speed.get() as f64;
        for (i, c) in self.dchannels.borrow_mut().iter_mut().enumerate() {
            if i >= self.channel_num.get() {
                break;
            }
            if c.length == 0 {
                c.length = len;
                c.begin_pts = c_pts;
                return Some(i);
            }
            if ((self.ctx.cm.danmaku_speed.get() as f64 - c_pts as f64 + c.begin_pts as f64) * s) > 1920.0 {
                continue;
            } else if ((c.length + 1920) as f64 * (c_pts as f64 - c.begin_pts as f64)
                / self.ctx.cm.danmaku_speed.get() as f64)
                < c.length as f64
            {
                continue;
            } else {
                c.length = len;
                c.begin_pts = c_pts;
                return Some(i);
            }
        }
        None
    }

    fn get_danmaku_display_length(&self, nick: &str, dm: &str) -> usize {
        let mut ascii_num = 0;
        let mut non_ascii_num = 0;
        for c in dm.chars() {
            if c.is_ascii() {
                ascii_num += 1;
            } else {
                non_ascii_num += 1;
            }
        }
        if self.show_nick.get() {
            for c in nick.chars() {
                if c.is_ascii() {
                    ascii_num += 1;
                } else {
                    non_ascii_num += 1;
                }
            }
            non_ascii_num += 1;
        }
        let fs = self.font_size.get();
        (((fs as f64 * 0.75 * non_ascii_num as f64) + (fs as f64 * 0.50 * ascii_num as f64)) * self.ratio_scale.get())
            .round() as usize
    }

    fn launch_single_danmaku(
        &self, d: &DMLDanmaku, cluster: &RefCell<mkv_header::DMKVCluster>, track_number: u8,
    ) -> Result<()> {
        let mut out_of_channel = false;
        let mut f1 = || {
            d.color.trim().is_empty().not().then(|| {})?;
            let display_length = self.get_danmaku_display_length(&d.nick, &d.text);
            self.get_avail_danmaku_channel(d.time as u64, display_length)
                .or_else(|| {
                    out_of_channel = true;
                    None
                })
                .map(|it| (it, display_length))
        };
        let (ass, du) = if d.position == 0 {
            match f1() {
                Some((avail_dc, display_length)) => {
                    let ass = format!(
                        r"{4},0,Default,{5},0,0,0,,{{\alpha{0}\fs{7}\1c&{6}&\move(1920,{1},{2},{1})}}{8}{9}{3}",
                        format_args!("{:02x}", (self.ctx.cm.font_alpha.get() * 255_f64) as u8),
                        avail_dc * self.font_size.get(),
                        0 - display_length as isize,
                        &d.text,
                        self.read_order.get(),
                        &d.nick,
                        format_args!("{}{}{}", &d.color[4..6], &d.color[2..4], &d.color[0..2]),
                        self.font_size.get(),
                        if self.show_nick.get() { &d.nick } else { "" },
                        if self.show_nick.get() { ": " } else { "" },
                    )
                    .into_bytes();
                    (ass, self.ctx.cm.danmaku_speed.get())
                    // (ass, 1000)
                }
                None => {
                    let ass = format!(r"{},0,Default,dmlive-empty,0,0,0,,", self.read_order.get()).into_bytes();
                    (ass, if track_number == 1 { 0 } else { 200 })
                }
            }
        } else {
            let ass = format!(
                r"{0},0,Default,{1},0,0,0,,{{\alpha{2}\fs{3}\1c&{4}&\an{5}}}{6}{7}{8}",
                self.read_order.get(),
                &d.nick,
                format_args!("{:02x}", (self.ctx.cm.font_alpha.get() * 255_f64) as u8),
                self.font_size.get(),
                format_args!("{}{}{}", &d.color[4..6], &d.color[2..4], &d.color[0..2]),
                d.position,
                if self.show_nick.get() { &d.nick } else { "" },
                if self.show_nick.get() { ": " } else { "" },
                &d.text,
            )
            .into_bytes();
            (ass, self.ctx.cm.danmaku_speed.get())
        };
        self.read_order.update(|x| x + 1);
        let _ = cluster.borrow_mut().add_ass_block(d.time as u64, ass, du, track_number);
        // out_of_channel.not().then(|| {}).ok_or_else(|| anyhow!("channels unavailable"))
        Ok(())
    }

    async fn launch_live_danmaku_task(&self, rx: async_channel::Receiver<DMLDanmaku>) -> Result<()> {
        let mut socket = self.ctx.im.get_danmaku_socket().await?;
        let now = std::time::Instant::now();
        let padding_time = Cell::new(0);
        let mut empty_dm = DMLDanmaku {
            text: "".to_string(),
            nick: "".to_string(),
            color: "".to_string(),
            time: 0,
            position: 0,
        };
        let mkv_cluster = RefCell::new(mkv_header::DMKVCluster::new());
        socket.write_all(mkv_header::MKV_HEADER).await?;
        let t1 = async {
            while let Ok(mut dml_dm) = rx.recv().await {
                if !self.ctx.cm.quiet {
                    println!("[{}] {}", &dml_dm.nick, &dml_dm.text);
                }
                if !self.fk.dm_check(&dml_dm.text) {
                    continue;
                }
                dml_dm.time = now.elapsed().as_millis() as i64 + padding_time.get();
                self.launch_single_danmaku(&dml_dm, &mkv_cluster, 1)?;
            }
            anyhow::Ok(())
        };

        let t2 = async {
            let mut interval = tokio::time::interval(tokio::time::Duration::from_millis(1000));
            mkv_cluster.borrow_mut().reset(0);
            for _ in 0..100 {
                empty_dm.time = padding_time.get();
                padding_time.update(|x| x + 1);
                self.launch_single_danmaku(&empty_dm, &mkv_cluster, 1)?;
                self.launch_single_danmaku(&empty_dm, &mkv_cluster, 2)?;
            }
            loop {
                interval.tick().await;
                let now_ts = now.elapsed().as_millis() as i64 + padding_time.get();
                empty_dm.time = now_ts;
                self.launch_single_danmaku(&empty_dm, &mkv_cluster, 1)?;
                self.launch_single_danmaku(&empty_dm, &mkv_cluster, 2)?;
                let data = mkv_cluster.borrow().write_to_bytes();
                mkv_cluster.borrow_mut().reset(now_ts as u64);
                socket.write_all(&data).await?;
            }
            #[allow(unreachable_code)]
            anyhow::Ok(())
        };
        tokio::select! {
            it = t1 => { it?; },
            it = t2 => { it?; },
        }
        Ok(())
    }

    async fn launch_video_danmaku_task(&self, rx: async_channel::Receiver<DMLDanmaku>) -> Result<()> {
        self.ready_notify.1.set(true);
        let mut socket = self.ctx.im.get_danmaku_socket().await?;
        // wait for ratio_scale ready
        self.ready_notify.0.notified().await;
        self.ready_notify.1.set(false);

        let mut dm_map: BTreeMap<i64, DMLDanmaku> = BTreeMap::new();
        while let Ok(d) = rx.recv().await {
            dm_map.insert(d.time, d);
        }
        socket.write_all(ASS_HEADER_TEXT.as_bytes()).await?;
        for (k, v) in dm_map.into_iter() {
            info!("{}-{}-{}-{}", k, &v.text, v.position, &v.color);
            let t1 = NaiveTime::from_hms_opt(0, 0, 0).unwrap() + Duration::milliseconds(k);
            let t2 = t1 + Duration::milliseconds(self.ctx.cm.danmaku_speed.get() as i64);
            let mut t1_s = t1.format("%k:%M:%S%.3f").to_string();
            let mut t2_s = t2.format("%k:%M:%S%.3f").to_string();
            t1_s.remove(t1_s.len() - 1);
            t2_s.remove(t2_s.len() - 1);
            if v.position == 0 {
                let display_length = self.get_danmaku_display_length(&v.nick, &v.text);
                let avail_dc = match self.get_avail_danmaku_channel(k as u64, display_length) {
                    Some(it) => it,
                    None => {
                        continue;
                    }
                };
                let ass = format!(
                    r#"Dialogue: 0,{4},{5},Default,,0,0,0,,{{\alpha{0}\fs{7}\1c&{6}&\move(1920,{1},{2},{1})}}{3}"#,
                    format_args!("{:02x}", (self.ctx.cm.font_alpha.get() * 255_f64) as u8),
                    avail_dc * self.font_size.get(),
                    0 - display_length as isize,
                    v.text,
                    t1_s,
                    t2_s,
                    format_args!("{}{}{}", &v.color[4..6], &v.color[2..4], &v.color[0..2]),
                    self.font_size.get(),
                );
                socket.write_all(ass.as_bytes()).await?;
                socket.write_all("\n".as_bytes()).await?;
            } else {
                let ass = format!(
                    r#"Dialogue: 0,{4},{5},Default,,0,0,0,,{{\alpha{0}\fs{3}\1c&{2}&\an{6}}}{1}"#,
                    format_args!("{:02x}", (self.ctx.cm.font_alpha.get() * 255_f64) as u8),
                    v.text,
                    format_args!("{}{}{}", &v.color[4..6], &v.color[2..4], &v.color[0..2]),
                    self.font_size.get(),
                    t1_s,
                    t2_s,
                    v.position
                );
                socket.write_all(ass.as_bytes()).await?;
                socket.write_all("\n".as_bytes()).await?;
            }
        }
        Ok(())
    }

    pub async fn danmaku_client_task(&self, dtx: async_channel::Sender<DMLDanmaku>) -> Result<()> {
        loop {
            match match self.ctx.cm.site {
                Site::BiliLive => {
                    let b = bilibili::Bilibili::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::BiliVideo => {
                    let b = bilivideo::Bilibili::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::BahaVideo => {
                    let b = baha::Baha::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::DouyuLive => {
                    let b = douyu::Douyu::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::HuyaLive => {
                    let b = huya::Huya::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::TwitchLive => {
                    let b = twitch::Twitch::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
                Site::YoutubeLive => {
                    let b = youtube::Youtube::new(self.ctx.clone());
                    b.run(dtx.clone()).await
                }
            } {
                Ok(_) => {}
                Err(e) => {
                    info!("danmaku client error: {:?}", e);
                }
            };
            if dtx.is_closed() {
                break;
            }
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        }
        info!("danmaku client exited.");
        Ok(())
    }

    // pub async fn run_baha(&self) -> Result<()> {
    //     self.reset();
    //     let (dtx, drx) = async_channel::unbounded();
    //     let (dc_res, fbd_res) = tokio::join!(
    //         self.danmaku_client_task(dtx),
    //         self.launch_video_danmaku_task(drx)
    //     );
    //     dc_res?;
    //     fbd_res?;
    //     info!("baha danmaku exited");
    //     Ok(())
    // }
    //
    // pub async fn run_bilivideo(&self, ratio_scale: f64) -> Result<()> {
    //     info!("ratio: {}", &ratio_scale);
    //     self.reset();
    //     self.ratio_scale.set(ratio_scale);
    //     let (dtx, drx) = async_channel::unbounded();
    //     let (dc_res, fbd_res) = tokio::join!(
    //         self.danmaku_client_task(dtx),
    //         self.launch_video_danmaku_task(drx)
    //     );
    //     dc_res?;
    //     fbd_res?;
    //     info!("bilibili video danmaku exited");
    //     Ok(())
    // }

    pub async fn run(&self) -> Result<()> {
        self.reset();
        let (dtx, drx) = async_channel::unbounded();
        let t1 = async {
            match self.ctx.cm.site {
                Site::BiliVideo | Site::BahaVideo => {
                    self.launch_video_danmaku_task(drx).await?;
                }
                _ => {
                    self.launch_live_danmaku_task(drx).await?;
                }
            }
            anyhow::Ok(())
        };
        let (r1, r2) = tokio::join!(self.danmaku_client_task(dtx), t1);
        r1?;
        r2?;
        info!("danmaku finished");
        std::future::pending::<()>().await;
        Ok(())
    }
}
